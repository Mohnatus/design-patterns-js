[Порождающие шаблоны](../#readme) / Строитель

# Строитель (Builder)

## Содержание

* [Описание паттерна](#-описание-паттерна)
* [Реализация паттерна](#-реализация-паттерна)
* [Примеры](#-примеры)
* [Использование](#-использование)
* [Преимущества](#-преимущества)
* [Недостатки](#-недостатки)
* [Похожие паттерны](#-похожие-паттерны)
* [Взаимодействие с другими паттернами](#-взаимодействие-с-другими-паттернами)
* [Источники](#источники)



## ![](../../ui/info.svg) Описание паттерна


### Абстрактная ситуация. Компьютеры и комплектующие

Представьте, что вы продаете компьютеры - уже собранные, полностью функционирующие. К вам приходят заказчики, высказывают свои пожелания, а вы на их основе комплектуете все необходимое.

Заказы могут быть самые разные:

* дополнительный монитор или даже два
* без звуковой карты
* с джойстиком
* нестандартная клавиатура
* и т. д.

То есть настройка каждого узла может быть довольно тонкой. Кажется, пора это все выделять в отдельный класс.

***

Строитель - это более сложная `Фабрика`. Если `Фабрика` просто выбирает нужный подкласс объектов в зависимости от параметров, строитель может осуществлять **более тонкую настройку**, например, использовать разные алгоритмы сборки объекта. В результате, на выходе могут получаться *совершенно разные объекты одного и того же подкласса*.

Паттерн инкапсулирует **процесс создания сложных объектов**: скрывает сложные детали  создания и позволяет изменять внутреннее представление объектов. Внутри строителя вы имеете **полный контроль над каждым шагом создания объекта**.

`Строитель` даёт возможность использовать один и тот же код строительства для получения разных представлений объектов. Он разбивает создание объекта *на несколько этапов* вместо того, чтобы делать это сразу в конструкторе.


### Разные Строители

При этом разные строители могут выполнять одну и ту же задачу, с одними и теми же параметрами по-разному. Например:

* один сделает вам стандартный ПК, а другой - моноблок
* один использует процессоры Intel, а второй - AMD
* один собирает компьютер из комплектующих, а второй описывает эти комплектующие в мануале

Конечные продукты функционально очень похожи, клиент может ими пользоваться, но тем не менее они разные.

Вы всегда можете добавить в программу нового `Строителя`, чтобы получать новый тип продукта.


### Директор

Если процесс *строительства* довольно сложен (имеется определенная последовательность шагов или разные способы осуществления операций), вы можете инкапсулировать и его. Вместо того, чтобы вызывать методы `Строителя` прямо из клиентского кода, создайте класс `Директора`, который будет делать это за вас - ему только нужно передать экземпляр `Строителя`.

Обычно конечный результат работы вы будете получать от самих строителей, а не от директора, чтобы не привязывать его к конкретным классам строителей (у которых может быть разный интерфейс метода получения результата `getComputer`, `getManual`).



## ![](../../ui/gear.svg) Реализация паттерна

![Схема паттерна Строитель](./scheme/scheme.png)

* Строители
  * Интерфейс `Builder` определяет методы сборки объекта
  * Классы конкретных строителей `ConcreteBuilder` реализуют эти методы
* `Director` руководит процессом сборки объектов
* Клиентский код просто выбирает `КонкретногоСтроителя`, передает его `Директору` и получает готовый продукт.



## ![](../../ui/code.svg) Примеры

* [Постройка дома](./building#readme)
* [Сборка объекта запроса](./request#readme)



## ![](../../ui/question.svg) Использование

* Конструктор вашего класса стал слишком громоздким, так как приходится передавать много параметров для настройки.
* Требуется создавать разные представления одного и того же функционала (ПК и моноблок).
* Нужно производить сложные объекты, например, рекурсивные (деревья [Компоновщика](../../structural/composite#readme)). Или такие, производство которых можно разделить на несколько шагов.



## ![](../../ui/good.svg) Преимущества

* Возможно пошаговое создание продуктов
* Можно изменять представление продукта
* Изоляция сложного кода сборки



## ![](../../ui/bad.svg) Недостатки

* Введение дополнительных классов
* Если у `Строителей` нет общего метода получения результата, то клиент привязан к интерфейсу разных `Строителей`.



## ![](../../ui/twins.svg) Похожие паттерны

* [Фабричный метод (Factory method)](../factoryMethod#readme). Простой выбор нужного подкласса (без настройки).
* [Абстрактная фабрика (Abstract factory)](../abstractFactory#readme). Фабрика фабрик.

Строитель часто является эволюцией паттерна `Фабричный метод`.



## ![](../../ui/interaction.svg) Взаимодействие с другими паттернами

**Способы реализации паттерна (вариации механизмов работы паттерна)**

* [Мост (Bridge)](../../structural/bridge#readme). Строитель может быть оформлен в виде `Моста`, где `Директор` - абстракция, а `Строители` - реализации.
* [Одиночка (Singleton)](../singleton#readme). `Строитель` может быть `Синглтоном`.

**Частое применение (паттерны не связаны напрямую)**

* [Компоновщик (Composite)](../../structural/composite#readme). `Строитель` пошагово сооружает дерево `Компоновщика`.



## Источники

* [refactoring.guru](https://refactoring.guru/ru/design-patterns/builder)
* [wikipedia](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%BE%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))
