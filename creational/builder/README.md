[Главная](../../#readme) / [Порождающие шаблоны](../#readme) / Строитель

# Строитель (Builder)

## Абстрактная ситуация. Компьютеры и комплектующие

Представьте, что вы продаете компьютеры - уже собранные, полностью функционирующие. К вам приходят заказчики, высказывают свои пожелания, а вы на их основе комплектуете все необходимое.

Заказы могут быть самые разные:

* дополнительный монитор или даже два
* без звуковой карты
* с джойстиком
* нестандартная клавиатура
* и т. д.

То есть настройка каждого узла может быть довольно тонкой. Кажется, пора это все выделять в отдельный класс.

## ![](../../ui/info.svg) Описание паттерна

Строитель - это более сложная `Фабрика`. Если `Фабрика` просто выбирает нужный подкласс объектов в зависимости от параметров, строитель может осуществлять **более тонкую настройку**, например, использовать разные алгоритмы сборки объекта. В результате, на выходе могут получаться *совершенно разные объекты одного и того же подкласса*.

Паттерн инкапсулирует **процесс создания сложных объектов**: скрывает сложные детали  создания и позволяет изменять внутреннее представление объектов. Внутри строителя вы имеете **полный контроль над каждым шагом создания объекта**.

### Разные Строители

При этом разные строители могут выполнять одну и ту же задачу, с одними и теми же параметрами по-разному. Например:

* один сделает вам стандартный ПК, а другой - моноблок
* один использует процессоры Intel, а второй - AMD
* один собирает компьютер из комплектующих, а второй описывает эти комплектующие в мануале

Конечные продукты функционально очень похожи, клиент может ими пользоваться, но тем не менее они разные.

Вы всегда можете добавить в программу нового `Строителя`, чтобы получать новый тип продукта.

### Директор

Если процесс *строительства* довольно сложен (имеется определенная последовательность шагов или разные способы осуществления операций), вы можете инкапсулировать и его. Вместо того, чтобы вызывать методы `Строителя` прямо из клиентского кода, создайте класс `Директора`, который будет делать это за вас - ему только нужно передать экземпляр `Строителя`.

Обычно конечный результат работы вы будете получать от самих строителей, а не от директора, чтобы не привязывать его к конкретным классам строителей (у которых может быть разный интерфейс метода получения результата `getComputer`, `getManual`).

## Реализация паттерна

![Схема паттерна Строитель](./scheme/scheme.png)

* Строители
  * Интерфейс `Builder` определяет методы сборки объекта
  * Классы конкретных строителей `ConcreteBuilder` реализуют эти методы
* `Director` руководит процессом сборки объектов
* Клиентский код просто выбирает `КонкретногоСтроителя`, передает его `Директору` и получает готовый продукт.

## Примеры

* [Постройка дома](./building#readme)
* [Сборка объекта запроса](./request#readme)

## Использование

* Конструктор вашего класса стал слишком громоздким, так как приходится передавать много параметров для настройки.
* Требуется создавать разные представления одного и того же функционала (ПК и моноблок).
* Нужно производить сложные объекты, например, рекурсивные. Или такие, производство которых можно разделить на несколько шагов.

## Преимущества

* Возможно пошаговое создание продуктов
* Изоляция сложного кода сборки

## Недостатки

* Введение дополнительных классов
* Если у `Строителей` нет общего метода получения результата, то клиент привязан к интерфейсу разных `Строителей`.

## Похожие паттерны

* [Фабричный метод (Factory method)](../factoryMethod#readme). Простой выбор нужного подкласса (без настройки).
* [Абстрактная фабрика (Abstract factory)](../abstractFactory#readme). Фабрика фабрик.

Строитель часто является эволюцией паттерна `Фабричный метод`.

## Взаимодействие с другими паттернами

* Способы реализации паттерна (вариации механизмов работы паттерна)
  * [Мост (Bridge)](../../structural/bridge#readme). Строитель может быть оформлен в виде `Моста`, где `Директор` - абстракция, а `Строители` - реализации.
  * [Одиночка (Singleton)](../singleton#readme). `Строитель` может быть `Синглтоном`.
* Частое применение (паттерны не связаны напрямую)
  * [Компоновщик (Composite)](../../structural/composite#readme). `Строитель` пошагово сооружает дерево `Компоновщика`.

## Источники

* [refactoring.guru](https://refactoring.guru/ru/design-patterns/builder)
